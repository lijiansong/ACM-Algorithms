## 2019 ByteDance Summer Camp

19年夏令营，头条请了天奇大神过去做talk，我是冲着天奇大佬去的，他是做DL编译器的，跟我个人的研究方向很类似，所以很期望能跟他当面交流一下。

夏令营有两次笔试机会，取成绩最高的一次作为最终的成绩。由于消息看到得晚，在下开始申请的时候，第一次笔试已经结束了。本人只参加了第二次笔试，笔试题目构成如下：单选题3题、不定向选择题1题、填空题2题、编程题3题、设计类1题，共5类题目，时间两个半小时(晚上7点-9点半)。

![ps](./img/summer-camp-19.png)

笔试是在牛客网完成的，笔试有一个特殊的要求：某一类题型全部做完了才能进入下一个题型，而且该类题型提交以后就不能修改了。比如说，选择题有3题，你把3题全部做完了，点提交，才能去做其他类型的题目，一旦提交了就不能回过头修改。所以合理安排时间非常重要，不能卡在某一类题目上太多时间，我是把非编程题类题目全部做完以后才去做的编程题。

**单选题一**：位示图管理。操作系统磁盘管理的问题：给定柱面、磁道和扇区数据，利用位示图对存储管理；

**单选题二**：二进制含0的数量。操作系统内存页映射的问题：限定问题场景，1GB内存，划分为131072个内存块。给定一段简单的C++代码,开了一个1024大小的int数组，一段循环对该数组的每个元素按照某个规律赋值，同时给定操作系统逻辑页号和内存块号的映射表。假设数组的逻辑地址是64C0，从物理地址A6BC取4个字节的数据。问该数据二进制0的个数。
该题目不是很难，但是手工计算量挺大的，`131072=2^17`(我除了好久才除出来:D)，`1GB=2^30B`，所以块大小是`2^30B/2^17=2^13B=8KB`，所以内存逻辑页的layout关系大概是：

```
第0页：0 ... 1FFF
第1页：2000 ... 3FFF
第2页：4000 ... 5FFF
第3页：6000 ... 7FFF
第4页：8000 ... 9FFF
第5页：A000 ... BFFF
第6页：C000 ... DFFF
第7页：E000 ... FFFF
...
```

数组的逻辑起始地址是64C0，数组大小是1024个int，即4KB，半个内存页。逻辑页号从0开始，可以大概算出来，`64C0所在的逻辑页号为3，页内偏移为4C0=1216`，
根据逻辑页和物理块的映射表，可以查出来，第3页对应的物理块号是第5块。而物理地址A6BC恰好也在第5块，`物理地址的块内偏移是6BC=1724`，数组的大小是4KB，所以并不会出现跨页的现象，所以从物理地址A6BC取4个字节的数据实际上取的数据是`(1724-1216)/4=127`,即从数组的第127个数据，把该数据转换成二进制表示，数一下0的个数即可。

**单选题三**：牙齿-集合，智力题。黑帽子白帽子问题（或者红眼蓝眼问题）的变种，当时尝试着用数学归纳法，理性地去分析了一下，发现没有选项，所以就随便选了一个:-)

**不定向选择题**：全局变量，操作系统多线程局部变量和全局变量问题。a是全局变量，初始值为0，两个线程分别执行以下代码：

```
for (int i = 1; i <= 2; ++i)
  a += (i * ((i % 2) ? 1 : -1);
```

问最终a的可能取值是多少？
这里的i是私有变量，每个线程会有单独的副本，而a是全局变量，对每个线程都可见。把循环展开以后，每个线程的实际操作就是：

```
a += 1;
a += -2;
```

运算符`+=`相当于先读后写，有读写相关，所以每个线程的实际操作如下：

```
load R0, (a);   读a的值
add R1, R0, 1;  计算临时结果
store R1, (a);  写回结果
load R2, (a);   读a的值
add R3, R2, -2; 计算临时结果
store R3, (a);  写回计算结果
```

R表示读，C表示计算，W表示写，则可以简写成RCWRCW，R和W之间存在相关，W和W之间存在相关，对两个线程枚举出所有可能相关的情况(每个线程内部的指令相对有序)，就是最终可能的结果。


**填空题一**：含6的个数。数学题，`1^2 + 3^2 + 5^2 + ... + (2n-1)^2 = M`，当n=5*10^10的时候，求M中含数字6的个数。拿到这一题，第一反应，纯数学问题啊，但是M怎么算出来呢？本人的记忆里，`1^2 + 2^2 + ... + n^2`等于什么呢？忘记了，大概是n(n+1)(2n+1)/6，手动举了几个corner case验证了一下，确实是这个，那么：

```
S0 = 1^2 + 2^2 + 3^2 + ... + (2n)^2 = 2n(2n+1)(2*2n+1)/6
S1 = 2^2 + 4^2 + ... + (2n)^2 = (2*1)^2 + (2*2)^2 + ... + (2*n)^2
   = 4*(1^2 + 2^2 + 3^2 + ... + n^2)
   = 4*n(n+1)(2n+1)/6
S0 = M + S1
所以，M = S0 - M = n(2n-1)(2n+1)/3
```

所以，当`n = 5*10^10`的时候，M的值直接代入公式，

```
M = 5*10^10*(2*5*10^10-1)(2*5*10^10+1)/3
  = 5*10^10*(10^11-1)(10^11+1)/3
```

M是个整数，所以(10^11 - 1)*(10^11 + 1)必定能被3整除，然后这个问题就成了一个找规律的问题了，`x = (10^k - 1)*(10^k + 1)`的结果很有规律：

```
k = 1, x = 99;
k = 2, x = 9999;
k = 3, x = 999999;
...
```

规律很明显，`当k=11的时候，(10^11-1)(10^11+1)=999...9,总共22个9`，所以

```
M = 5*10^10*333...3(22个3)
```

所以答案也很明显了，M应该有21个6。

**填空题二**：10枚外观相同的硬币，1枚假硬币重量跟其他硬币不同，给一个天平，最少称重多少次能够确定假硬币，最多称重多少次能确定假币？而且题目也没说假币是比其他硬币轻了还是重了，感觉这题歧义挺大的，看你怎么理解最多和最少了。
我是这么理解的，因为题目只是说假币跟其他硬币质量不同，并没有说假币是轻还是重，所以不能按照`5,5->2,2,1`的方式去简单地判断。

```
如果刚开始分为`5, 5`两堆，那么第1次称重。
假设取了轻的一边:
  为了确认假币就是轻的，你需要在轻的一边中继续确认，`5->2, 2, 1`三堆，第2次称重2v2：
    如果2v2质量相同，你需要确认假币是轻的还是重的，所以需要在4个中随机取1个，跟剩下的一个进行第3次1v1称重：
      如果1v1质量不同，那么剩下的那个肯定是假币，而且这种情况的结果只能是假币是轻的。
      如果1v1质量相同，那么说明第1次称重取错了，可以确认假币是重的。所以应该在另外5个中再最多进行2次或者最少进行1次的称重判断。
    如果2v2质量不同，那么可以确认假币就是轻的，那么再进行1次判断即可。
假设取了重的一边，思路类似。
```

所以在这种思维模式下，最少需要3次，最多需要5次。

看到群里有人说把硬币分`3, 3, 4`三堆的情况。

```
先3v3第1次称重：
  如果3v3质量相同，则假币在4中，2v2第2次称重：
    如果取了轻的一边，那么1v1第3次称重；
      如果1v1质量相同，那么说明取错了，可以确认假币就是重的；所以再进行第4次称重就可以确认假币；
      如果1v1质量不同，那只可能是轻的是假币。
    如果取了重的一边，思路类似。
  如果3v3质量不同，则还需要判断假币的轻重：
    假设取了轻的一边，先1v1进行第2次称重:
      如果质量相同，需要确定假币是轻还是重的，需要在2个中随便取一个跟剩下的进行第3次1v1称重；
        如果1v1质量相同，可以确认假币是重的，在重的3个中在进行一次称重就可以确认假币；
        如果1v1质量不同，可以确认假币是轻的，轻的一边即为假币；
      如果质量不同，可以确认轻的一边即为假币；
    假设取了重的一边，思路类似。
```
所以在这种思维模式下，最少需要2次，最多需要4次。

**编程题一**：立方体塔，题目大意：给定w个白色方块和b个黑色方块，用它们去搭一个塔。塔的要求是第h层有h个相同颜色的方块。输入是w和b，输出塔的最高层数以及塔的种类(某一层颜色不同可以认为是不同的种类)。

**编程题二**：变量名拆分。给定一个字符串，即变量名，和一个字符串集合，判断能否拆开变量名，使得拆开后的字符串集合是给定字符串集合的子集。e.g.:输入变量名："thisisadog"，字符串集合：{"this", "thisis", "is", "a", "dog"}，这个例子应该输出True.
其实是多模式字符串匹配问题。

**编程题三**：宝石迷阵。时间有限，在下还没看完懂题目就被强制提交了。


**问答题**：群聊消息。系统设计问题，针对钉钉等企业应用的群聊消息状态(已读或者未读)功能设计核心数据结构。要求解决场景问题，指出操作流程和时间复杂度，并指出至少两个关键挑战。

感觉主要解决三个场景问题：

```
1. 新用户加入或者退出群聊；
2. 新消息的发布；
3. 某个用户读取了某个消息。
```

当时主要想法是，实际应用场景中，`消息的数目明显多余用户数目的`，所以设计的核心数据结构是一个hashmap，msg_id为key，value是一个bitmap，长度为用户数目，bitmap以usr_id索引用户对该消息的读取状态，0表示未读，1表示读取，初始化构造的时候，默认消息是未读的。

1. 当有新的用户加入或者退出群聊的时候，bitmap的长度需要更新，不考虑之前历史信息的情况下(即后进群的人看不到之前的消息)，有新消息发布的时候再对bitmap扩容。

2. 新消息的发布，则hashmap中需要插入新的记录，bitmap的默认值全0，表示消息未读取，复杂度O(1)。

3. 用户u读取了消息m，则根据msg_id拿到位图的bitmap，利用usr_id更新位图的状态。

msg_id和usr_id用64位整型表示，假设有N个用户和M个消息，则占用内存大小为N*M/8.

所以，对外暴露的接口至少要有4个：

```
void usr_comming(long usr_id); // 新用户加入群聊
void usr_leaving(long usr_id); // 用户退出群聊
void new_msg_pub(long pub_usr_id, long msg_id); // 用户发布消息
void usr_read_msg(long usr_id, long msg_id); // 用户读取了某条消息
```


两个关键挑战：

1. 用户数目变化时，考虑到系统的复杂均衡，可以采用延时策略。对于用户的减少，即用户退出了群聊，为了保证系统的稳定，可以考虑并不立即缩短bitmap的宽度，可以延时到某个时刻再执行缩短操作；对于用户的增加，

2. 随着消息数目增加，占用的内存量也会增加，考虑到系统的存储压力，所以需要维护一定的时间窗口，把时间窗口之外的数据存到磁盘中。对于那些全部已读的消息，也可以考虑把它们存到磁盘中。


**个人总结**：

- 单选题手工计算量挺大的，某一个小的环节算错了，该题目基本就gg了；本人当时笔试的时候，内存页表映射那题，加减法算错了，怎么都得不出选项:-)数学题的公式推了5分钟，最后把忘记除以6，也挺无语的。所以需要很细心，不能大意；
- 智力题有时候还是需要动脑子练习一下的；
- 第一次做系统设计题，也不知道该从哪些角度去回答这些问题，经过此次总结，大概知道了如何回答系统设计题。首先需要分析应用场景，需要解决哪些核心的问题，然后封装抽象出核心的数据结构，给出类的设计，以及暴露出来的核心接口，并简述每个接口的实现流程并做复杂度分析。最后从系统扩展性的角度指出可能会出现的瓶颈问题。































